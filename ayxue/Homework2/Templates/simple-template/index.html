<!DOCTYPE html>
<html>
    <head>
<style>

#row-container {
    display: flex;
    flex-direction: row;
}
#container {
    display: flex;
    flex-direction: column;
}

body {
    top: 0;
    /* background-color: black; */
}

text {
    font-family: proxima-nova;
    font-size: 12px;
    fill: #666;
}

.countries {
    fill: #333333;
}

</style>
    </head>
    <body>
        <div id='container'>
            <div id="row-container">
                <div id='spikemap'></div>
                <div id='parasets'></div>
            </div>
            <div id="streamgraph"></div>
        </div>
        <script src="https://d3js.org/d3.v4.min.js"></script>
        <script src="https://d3js.org/topojson.v1.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.25.6/d3-legend.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-sankey/0.7.1/d3-sankey.min.js"></script>

        <script>

const map_margin = {top: 40, right: 30, bottom: 20, left: 30},
    map_width = 640 - map_margin.left - map_margin.right,
    map_height = 400 - map_margin.top - map_margin.bottom;
// const map_width = 450;
// const map_height = 300;
const stream_margin = {top: 40, right: 30, bottom: 20, left: 30},
    stream_width = 1180 - stream_margin.left - stream_margin.right,
    stream_height = 320 - stream_margin.top - stream_margin.bottom;

const para_margin = {top: 40, right: 30, bottom: 20, left: 30},
    para_width = 640 - para_margin.left - para_margin.right,
    para_height = 400 - para_margin.top - para_margin.bottom;



let mapsvg = d3.select('#spikemap')
                    .append('svg')
                    // .attr("viewBox", [0, 0, map_width, map_height])
                    // .attr('id', 'map')
                    .attr('width', map_width)
                    .attr('height', map_height);

let parasvg = d3.select('#parasets')
                    .append('svg')
                    // .attr("viewBox", [0, 0, map_width, map_height])
                    // .attr('id', 'map')
                    .attr('width', para_width)
                    .attr('height', para_height);

let streamsvg = d3.select("#streamgraph")
                    .append("svg")
                    // .attr("viewBox", [0, 0, stream_width, stream_height])
                    .attr("width", stream_width + stream_margin.left + stream_margin.right)
                    .attr("height", stream_height + stream_margin.top + stream_margin.bottom)
                    .append("g")
                    .attr("transform",
                        "translate(" + stream_margin.left + "," + stream_margin.top + ")");


let projection = d3.geoMercator().translate([map_width/2, map_height/2]),
    path = d3.geoPath(projection);


// let date_coord_filter = function(gname) {
//     let
// }

d3.queue()
    .defer(d3.json, 'world-50m.json')
    .defer(d3.csv, 'date_coord.csv')
    .defer(d3.csv, 'month_gname.csv')
    .defer(d3.csv, 'gname_attype.csv')
    .await(main);

function main(error, world, date_coord, month_gname, gname_attype) {
    let color = d3.scaleOrdinal()
        .domain(month_gname.columns.slice(1))
        .range(d3.schemeCategory10);
    let length = d3.scaleLinear([0, d3.max(date_coord, d => d.value)], [0, 10])
    let spike = (length, width = 7) => `M${-width / 2},0L0,${-length}L${width / 2},0`
    let keys = month_gname.columns.slice(1);

    // draw map
    date_coord.forEach(d => { d.coords = projection([d.longitude, d.latitude]); })
    let countries = topojson.feature(world, world.objects.countries).features;
    let borders = topojson.mesh(
        world,
        world.objects.countries,
        (a,b) => a == b ? 'coast' : d3.extent([a.id, b.id]).join('-')
        );

    mapsvg
        .append('g')
        .classed('countries', true)
        .selectAll(".country")
        .data(countries)
        .enter()
        .append("path")
        .attr("class", "country")
        .attr("d", path);

    mapsvg
        .append("path")
        .attr("fill", "none")
        .attr("stroke", "white")
        .attr('stroke-width', 0.1)
        .attr("stroke-linejoin", "round")
        .attr("d", path(borders));

    for (i in keys) {
        let gname = keys[i];
        let cl_name = gname.slice(0,3);
        g_data = date_coord.filter(d => d.gname == gname);

        mapsvg.append("g")
                    .classed(cl_name, true)
                    .selectAll('.events')
                    .data(g_data)
                    .enter()
                    .append('path')
                    // .attr("fill", function(d) { return color(d.gname);})
                    .attr("fill-opacity", 0.3)
                    .attr("stroke", function(d) { return color(d.gname);})
                    .attr("transform", d => `translate(${d.coords})`)
                    .attr("d", d => spike(length(d.value)))
    }

    // draw parasets
    para_keys = gname_attype.columns.slice(0, -1)
    console.log(para_keys)

    let index = -1;
    const _nodes = [];
    const nodeByKey = new Map;
    const indexByKey = new Map;
    const _links = [];

    for (const k of para_keys) {
        for (const d of gname_attype) {
        const key = JSON.stringify([k, d[k]]);
        if (nodeByKey.has(key)) continue;
        const node = {name: d[k]};
        _nodes.push(node);
        nodeByKey.set(key, node);
        indexByKey.set(key, ++index);
        }
    }

    for (let i = 1; i < para_keys.length; ++i) {
        const a = para_keys[i - 1];
        const b = para_keys[i];
        const prefix = para_keys.slice(0, i + 1);
        const linkByKey = new Map;
        for (const d of gname_attype) {
        const names = prefix.map(k => d[k]);
        const key = JSON.stringify(names);
        const value = d.value || 1;
        let link = linkByKey.get(key);
        if (link) { link.value += value; continue; }
        link = {
            source: indexByKey.get(JSON.stringify([a, d[a]])),
            target: indexByKey.get(JSON.stringify([b, d[b]])),
            names,
            value
        };
        _links.push(link);
        linkByKey.set(key, link);
        }
    }

    let graph = {_nodes, _links};
    let sankey = d3.sankey()
                // .nodeSort(null)
                // .linkSort(null)
                .nodeWidth(4)
                .nodePadding(20)
                .extent([[0, 5], [para_width, para_height - 5]])

    const {nodes, links} = sankey({
        nodes: graph._nodes.map(d => Object.assign({}, d)),
        links: graph._links.map(d => Object.assign({}, d))
    });

    parasvg.append("g")
            .selectAll("rect")
            .data(nodes)
            .enter()
            .append("rect")
            .attr("x", d => d.x0)
            .attr("y", d => d.y0)
            .attr("height", d => d.y1 - d.y0)
            .attr("width", d => d.x1 - d.x0)
            .append("title")
            .text(d => `${d.name}\n${d.value.toLocaleString()}`);

    console.log(links)

    parasvg.append("g")
            .attr("fill", "none")
            .selectAll("g")
            .data(links)
            .enter()
            .append("path")
            .attr("d", d3.sankeyLinkHorizontal())
            .attr("stroke", d => color(d.names[0]))
            .attr("stroke-width", d => d.width)
            .style("mix-blend-mode", "multiply")
            // .append("title")
            // .text(d => `${d.names.join(" â†’ ")}\n${d.value.toLocaleString()}`);

    parasvg.append("g")
            .style("font", "10px sans-serif")
            .selectAll("text")
            .data(nodes)
            .enter()
            .append("text")
            .attr("x", d => d.x0 < para_width / 2 ? d.x1 + 6 : d.x0 - 6)
            .attr("y", d => (d.y1 + d.y0) / 2)
            .attr("dy", "0.35em")
            .attr("text-anchor", d => d.x0 < para_width / 2 ? "start" : "end")
            .text(d => d.name)
            .append("tspan")
            .attr("fill-opacity", 0.7)
            .text(d => ` ${d.value.toLocaleString()}`);



    // draw streamgraph
    let series = d3.stack()
        .keys(month_gname.columns.slice(1))
        .offset(d3.stackOffsetWiggle)
        .order(d3.stackOrderInsideOut)
    (month_gname);

    // Add X axis
    let x = d3.scaleUtc()
        .domain(d3.extent(month_gname, d => new Date(d.date)))
        .range([stream_margin.left + 250, stream_width - stream_margin.right]);

    let y = d3.scaleLinear()
        .domain([d3.min(series, d => d3.min(d, d => d[0])), d3.max(series, d => d3.max(d, d => d[1]))])
        .range([stream_height - stream_margin.bottom, stream_margin.top]);

    let xAxis = g => g
        .attr("transform", `translate(0,${stream_height - stream_margin.bottom})`)
        .call(d3.axisBottom(x).ticks(stream_width / 40).tickSizeOuter(0))
        .call(g => g.select(".domain").remove());

    let area = d3.area()
            .x(d => x(new Date(d.data.date)))
            .y0(d => y(d[0]))
            .y1(d => y(d[1]));

    streamsvg.append("g")
        .call(xAxis);
    streamsvg.selectAll(".tick line").attr("stroke", "#b8b8b8")

    // streamgraph legend
    streamsvg.append("g")
        .attr("class", "legendOrdinal")
        .attr("transform", "translate(0,0)");

    var legendOrdinal = d3.legendColor()
                    .shape("path", d3.symbol().type(d3.symbolCircle).size(150)())
                    .shapePadding(10)
                    .scale(color);

    streamsvg.select(".legendOrdinal")
        .call(legendOrdinal);

    let Tooltip = streamsvg
                    .append("text")
                    .attr("x", 0)
                    .attr("y", 0)
                    .style("opacity", 0)
                    .style("font-size", 10)
    // Three function that change the tooltip when user hover / move / leave a cell

    let mouseover = function(d, i) {
        Tooltip.style("opacity", 1)
        d3.selectAll(".myArea").style("opacity", .2)
        d3.select(this)
            .style("stroke", "black")
            .style("opacity", 1)
        grp = keys[i]
        // Tooltip.text(grp)
        for (i in keys) {
            let gname = keys[i];
            let cl_name = gname.slice(0,3);
            if (gname == grp) {
                d3.selectAll('.'+cl_name).style('opacity', 1);
            }
            else {
                d3.selectAll('.'+cl_name).style('opacity', 0);
            }
        }
    }

    let mouseleave = function(d) {
        Tooltip.style("opacity", 0)
        d3.selectAll(".myArea").style("opacity", 1).style("stroke", "none")
        for (i in keys) {
            let gname = keys[i];
            let cl_name = gname.slice(0,3);
            d3.selectAll('.'+cl_name).style('opacity', 1);
        }
    }

    streamsvg.selectAll("mylayers")
            .data(series)
            .enter()
            .append("path")
            .attr("class", "myArea")
            .style("fill", function(d) { return color(d.key); })
            .attr("d", area)
            .on("mouseover", mouseover)
            // .on("mousemove", mousemove)
            .on("mouseleave", mouseleave)
}
        </script>
    </body>
</html>
